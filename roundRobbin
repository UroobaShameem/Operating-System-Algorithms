class Process:
    def __init__(self, pid, arrival_time, execution_time):
        self.pid = pid  # Process ID
        self.arrival_time = arrival_time    # Arrival time
        self.execution_time = execution_time   # Execution time
        self.remaining_time = execution_time  # Remaining time
        self.resume_instruction_address = 0  # Resume instruction address
        self.num_instructions = 0  # Number of instructions
        self.turnaround_time = 0 # Turnaround time
        self.utilization_time = 0 # Utilization time
        self.psw = 0   # Program status word
        self.scheduling_algo = "Round Robin" # Scheduling algorithm
        self.finish_time = 0   # Finish time


def round_robin(processes, quantum_size):   # Round robin algorithm
    current_time = 0    
    ready_queue = processes.copy()  # Ready queue is a copy of processes
    finished_processes = [] # Finished processes 

    while ready_queue:
         # Pop the first process in the ready queue and assign it to current process
        current_process = ready_queue.pop(0)

        # If the remaining time of the current process is less than or equal to the quantum size
        if current_process.remaining_time <= quantum_size: 
            # Add the remaining time of the current process to the current time
            current_time += current_process.remaining_time
            # Set the remaining time of the current process to 0
            current_process.remaining_time = 0
            # Set the finish time of the current process to the current time
            current_process.finish_time = current_time
            # Add the current process to the finished processes list
            finished_processes.append(current_process)
        else:
            # Add the quantum size to the current time
            current_time += quantum_size
            # Subtract the quantum size from the remaining time of the current process
            current_process.remaining_time -= quantum_size
            # Add the current process to the ready queue
            ready_queue.append(current_process)

        if ready_queue:
            # Next process is the first process in the ready queue
            next_process = ready_queue[0]
            # If the arrival time of the next process is greater than the current time
            if next_process.arrival_time > current_time:
                # Current time is the arrival time of the next process
                current_time = next_process.arrival_time

    calculate_metrics(finished_processes)


def calculate_metrics(processes):
    total_turnaround_time = 0
    total_utilization_time = 0

    for process in processes:
        #Turnaround time = Finish time - Arrival time
        process.turnaround_time = process.finish_time - process.arrival_time
        #Utilization time = Execution time - Remaining time
        process.utilization_time = process.execution_time - process.remaining_time

        #Add turnaround and utilization time to total turnaround and utilization time
        total_turnaround_time += process.turnaround_time
        total_utilization_time += process.utilization_time

    #Average turnaround time = Total turnaround time / Number of processes
    avg_turnaround_time = total_turnaround_time / len(processes)
    #Average utilization time = Total utilization time / Number of processes
    avg_utilization_time = total_utilization_time / len(processes)

    print("\nProcess\t\tTurnaround Time\t\tUtilization Time")
    for process in processes:
        print(f"{process.pid}\t\t{process.turnaround_time}\t\t\t{process.utilization_time}")

    print("\nAverage Turnaround Time:", avg_turnaround_time)
    print("Average Utilization Time:", avg_utilization_time)


def main():
    num_processes = int(input("How many processes do you want to create (3-5): "))
    if num_processes < 3 or num_processes > 5:
        print("Number of processes must be between 3 and 5.")
        return

    processes = []
    for pid in range(1, num_processes + 1):
        arrival_time = max(0, (pid - 1) * 2)  # Arrival time starting from 0 
        execution_time = int(input(f"Enter execution time for Process {pid} (<= 10): "))
        execution_time = min(10, execution_time) 

        processes.append(Process(pid, arrival_time, execution_time))

    quantum_size = int(input("Enter quantum size (<= 3): "))
    quantum_size = min(3, quantum_size)

    round_robin(processes, quantum_size)


if __name__ == "__main__":
    main()
